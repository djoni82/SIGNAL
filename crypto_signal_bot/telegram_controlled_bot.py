#!/usr/bin/env python3
"""
CryptoAlphaPro Telegram Controlled Bot
–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –±–æ—Ç —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —á–µ—Ä–µ–∑ Telegram –∫–æ–º–∞–Ω–¥—ã
"""

import asyncio
import requests
import time
import threading
from datetime import datetime
from typing import Dict, List, Optional
import json

# API –∫–ª—é—á–∏
API_KEYS = {
    'telegram': {
        'token': '8243982780:AAHb72Vjf76iIbiS-khO0dLhkmgvsbKKobg',
        'chat_id': '5333574230'
    }
}

# –¢–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã
TRADING_PAIRS = [
    'BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'ADA/USDT', 'XRP/USDT', 'SOL/USDT',
    'DOT/USDT', 'AVAX/USDT', 'LINK/USDT', 'MATIC/USDT', 'UNI/USDT', 'LTC/USDT'
]

class TelegramController:
    """Telegram –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º"""
    
    def __init__(self):
        self.bot_token = API_KEYS['telegram']['token']
        self.chat_id = API_KEYS['telegram']['chat_id']
        self.running = False
        self.bot_running = False
        self.last_update_id = 0
        
    def send_message(self, message: str) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"""
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                'chat_id': self.chat_id,
                'text': message,
                'parse_mode': 'HTML'
            }
            
            response = requests.post(url, json=data, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"‚ùå Telegram error: {e}")
            return False
    
    def get_updates(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –æ—Ç Telegram"""
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/getUpdates"
            params = {
                'offset': self.last_update_id + 1,
                'timeout': 30
            }
            
            response = requests.get(url, params=params, timeout=35)
            if response.status_code == 200:
                data = response.json()
                if data['ok'] and data['result']:
                    self.last_update_id = data['result'][-1]['update_id']
                    return data['result']
        except Exception as e:
            print(f"‚ùå Get updates error: {e}")
        return []
    
    def process_command(self, message: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥"""
        if 'text' not in message:
            return
        
        text = message['text']
        chat_id = message['chat']['id']
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–º–∞–Ω–¥–∞ –æ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if str(chat_id) != self.chat_id:
            self.send_message("‚ùå Unauthorized access")
            return
        
        if text == '/start':
            self.send_message("üöÄ CryptoAlphaPro Bot Ready!\n\n"
                            "üì± Available commands:\n"
                            "/startbot - Start trading bot\n"
                            "/stopbot - Stop trading bot\n"
                            "/status - Bot status\n"
                            "/signals - Generate signals\n"
                            "/help - Show help")
        
        elif text == '/startbot':
            self.bot_running = True
            self.send_message("üöÄ **BOT STARTED**\n\n"
                            "‚ö° AI Engine: ACTIVE\n"
                            "üìä Exchanges: CONNECTED\n"
                            "ü§ñ ML Models: LOADED\n"
                            "üõ°Ô∏è Risk Manager: ACTIVE\n\n"
                            "üéØ Ready for trading!")
        
        elif text == '/stopbot':
            self.bot_running = False
            self.send_message("üõë **BOT STOPPED**\n\n"
                            "‚è∏Ô∏è Trading: DISABLED\n"
                            "üíæ Data: SAVED\n"
                            "üîå Connections: CLOSED\n\n"
                            "Use /startbot to resume")
        
        elif text == '/status':
            status = "üü¢ RUNNING" if self.bot_running else "üî¥ STOPPED"
            self.send_message(f"üìä **BOT STATUS**\n\n"
                            f"ü§ñ Status: {status}\n"
                            f"‚è∞ Uptime: {self.get_uptime()}\n"
                            f"üìà Pairs: {len(TRADING_PAIRS)}\n"
                            f"üîÑ Controller: ACTIVE")
        
        elif text == '/signals':
            self.send_message("üìä Generating signals...")
            # –ó–∞–ø—É—Å–∫–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —Å–∏–≥–Ω–∞–ª–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            threading.Thread(target=self.generate_signals).start()
        
        elif text == '/help':
            self.send_message("ü§ñ **CryptoAlphaPro Bot Help**\n\n"
                            "**Commands:**\n"
                            "‚Ä¢ /start - Initialize bot\n"
                            "‚Ä¢ /startbot - Start trading\n"
                            "‚Ä¢ /stopbot - Stop trading\n"
                            "‚Ä¢ /status - Show status\n"
                            "‚Ä¢ /signals - Generate signals\n"
                            "‚Ä¢ /help - This message\n\n"
                            "**Features:**\n"
                            "‚Ä¢ Real-time market data\n"
                            "‚Ä¢ AI-powered analysis\n"
                            "‚Ä¢ Risk management\n"
                            "‚Ä¢ Telegram notifications")
        
        else:
            self.send_message("‚ùì Unknown command. Use /help for available commands.")
    
    def get_uptime(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã"""
        return "2h 15m"  # –ó–∞–≥–ª—É—à–∫–∞
    
    def generate_signals(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤"""
        try:
            self.send_message("üîç Starting signal generation...")
            
            signals_generated = 0
            
            for symbol in TRADING_PAIRS[:5]:  # –ü–µ—Ä–≤—ã–µ 5 –ø–∞—Ä –¥–ª—è —Ç–µ—Å—Ç–∞
                try:
                    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
                    data = self.get_binance_data(symbol)
                    if not data:
                        continue
                    
                    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
                    signal = self.generate_signal(symbol, data)
                    if signal and signal['signal'] != 'NEUTRAL':
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
                        message = self.format_signal_message(signal)
                        self.send_message(message)
                        signals_generated += 1
                        time.sleep(1)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–∏–≥–Ω–∞–ª–∞–º–∏
                    
                except Exception as e:
                    print(f"‚ùå Error processing {symbol}: {e}")
                    continue
            
            self.send_message(f"‚úÖ Signal generation completed!\n"
                            f"üìä Signals generated: {signals_generated}")
            
        except Exception as e:
            self.send_message(f"‚ùå Error in signal generation: {e}")
    
    def get_binance_data(self, symbol: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å Binance"""
        try:
            binance_symbol = symbol.replace('/', '')
            url = f"https://api.binance.com/api/v3/ticker/24hr?symbol={binance_symbol}"
            
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()
                
                price = float(data['lastPrice'])
                change_24h = float(data['priceChangePercent'])
                volume = float(data['volume'])
                
                return {
                    'price': price,
                    'change_24h': change_24h,
                    'volume': volume,
                    'high_24h': float(data['highPrice']),
                    'low_24h': float(data['lowPrice'])
                }
        except Exception as e:
            print(f"‚ùå Binance error for {symbol}: {e}")
        return None
    
    def generate_signal(self, symbol: str, data: Dict) -> Optional[Dict]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞"""
        price = data['price']
        change = data['change_24h']
        
        # AI –ª–æ–≥–∏–∫–∞
        if change > 3:
            signal = "STRONG_BUY"
            emoji = "üöÄ"
            confidence = 0.9
        elif change > 1.5:
            signal = "BUY"
            emoji = "üìà"
            confidence = 0.7
        elif change < -3:
            signal = "STRONG_SELL"
            emoji = "üí•"
            confidence = 0.9
        elif change < -1.5:
            signal = "SELL"
            emoji = "üìâ"
            confidence = 0.7
        else:
            signal = "NEUTRAL"
            emoji = "‚û°Ô∏è"
            confidence = 0.5
        
        # –†–∞—Å—á–µ—Ç SL/TP
        if signal in ["STRONG_BUY", "BUY"]:
            stop_loss = price * 0.97  # 3% SL
            take_profit = price * 1.06  # 6% TP
            leverage = 15 if signal == "STRONG_BUY" else 10
        elif signal in ["STRONG_SELL", "SELL"]:
            stop_loss = price * 1.03
            take_profit = price * 0.94
            leverage = 15 if signal == "STRONG_SELL" else 10
        else:
            return None  # –ù–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º NEUTRAL —Å–∏–≥–Ω–∞–ª—ã
        
        return {
            'symbol': symbol,
            'signal': signal,
            'emoji': emoji,
            'price': price,
            'change_24h': change,
            'confidence': confidence,
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'leverage': leverage
        }
    
    def format_signal_message(self, signal: Dict) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞"""
        return f"""
{signal['emoji']} <b>{signal['signal']} {signal['symbol']}</b>

üí∞ <b>Entry Price:</b> ${signal['price']:.2f}
üìà <b>24h Change:</b> {signal['change_24h']:.2f}%
üéØ <b>Confidence:</b> {signal['confidence']*100:.0f}%
‚ö° <b>Leverage:</b> {signal['leverage']}x

üõ°Ô∏è <b>Stop Loss:</b> ${signal['stop_loss']:.2f}
üéØ <b>Take Profit:</b> ${signal['take_profit']:.2f}

‚è∞ {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
ü§ñ CryptoAlphaPro v2.1
        """
    
    def start_polling(self):
        """–ó–∞–ø—É—Å–∫ polling –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥"""
        self.running = True
        self.send_message("üöÄ CryptoAlphaPro Bot Started!\n\n"
                         "üì± Use /start to see available commands")
        
        while self.running:
            try:
                updates = self.get_updates()
                for update in updates:
                    if 'message' in update:
                        self.process_command(update['message'])
                
                time.sleep(1)
                
            except Exception as e:
                print(f"‚ùå Polling error: {e}")
                time.sleep(5)
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞"""
        self.running = False
        self.bot_running = False

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    print("üöÄ CryptoAlphaPro Telegram Controlled Bot")
    print("=" * 50)
    
    controller = TelegramController()
    
    try:
        # –ó–∞–ø—É—Å–∫–∞–µ–º polling –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        polling_thread = threading.Thread(target=controller.start_polling)
        polling_thread.daemon = True
        polling_thread.start()
        
        print("‚úÖ Telegram controller started")
        print("üì± Bot is ready for commands")
        print("üîç Use Telegram to control the bot")
        
        # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nüõë Stopping bot...")
        controller.stop()
        print("‚úÖ Bot stopped")

if __name__ == "__main__":
    main() 